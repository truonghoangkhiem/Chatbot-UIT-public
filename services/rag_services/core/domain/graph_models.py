"""
Graph domain models for CatRAG Knowledge Graph.

This module defines domain models for graph entities aligned with
the CatRAG category-labeled schema.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum


class NodeCategory(str, Enum):
    """
    CatRAG Node Categories - STANDARDIZED SCHEMA
    
    All values are UPPER_SNAKE_CASE to match Neo4j labels directly.
    """
    # --- Core Academic Entities ---
    MON_HOC = "MON_HOC"                   # Course/Subject
    KHOA = "KHOA"                         # Faculty/Department
    NGANH = "NGANH"                       # Major
    CHUONG_TRINH_DAO_TAO = "CHUONG_TRINH_DAO_TAO" # Curriculum
    SINH_VIEN = "SINH_VIEN"               # Student Entity/Cohort
    KY_HOC = "KY_HOC"                     # Semester
    GIANG_VIEN = "GIANG_VIEN"             # Lecturer
    
    # --- Regulations & Rules ---
    QUY_DINH = "QUY_DINH"                 # Regulation Document/Article
    DIEU_KIEN = "DIEU_KIEN"               # General Condition
    
    # --- Extended Entities (New for Regulations 828, 1393) ---
    CHUNG_CHI = "CHUNG_CHI"               # Certificates (IELTS, TOEIC, MOS)
    DIEM_SO = "DIEM_SO"                   # Scores/Grades (450, 5.0, 8.0)
    DO_KHO = "DO_KHO"                     # Proficiency Levels (B1, N3, Intermediate)
    DOI_TUONG = "DOI_TUONG"               # Target Group (CLC, CTTT, Mass program)
    TAI_CHINH = "TAI_CHINH"               # Financial fees (Tuition, Fees)
    DIEU_KIEN_SO = "DIEU_KIEN_SO"         # Quantitative conditions (70 students, 12 credits)
    HOC_PHI = "HOC_PHI"                   # Alias for Financial/Tuition


class NodeStatus(str, Enum):
    """
    Status values for Article/Clause nodes to track legal modifications.
    """
    ACTIVE = "active"       # Currently in effect
    AMENDED = "amended"     # Modified by a newer document
    EXPIRED = "expired"     # No longer in effect (repealed)


class RelationshipType(str, Enum):
    """CatRAG Relationship Types"""
    # --- Hierarchical ---
    THUOC_KHOA = "THUOC_KHOA"             # MON_HOC/NGANH -> KHOA
    CUA_NGANH = "CUA_NGANH"               # MON_HOC -> NGANH
    THUOC_CHUONG_TRINH = "THUOC_CHUONG_TRINH" # MON_HOC -> CHUONG_TRINH
    QUAN_LY = "QUAN_LY"                   # KHOA -> NGANH/MON_HOC
    THUOC_VE = "THUOC_VE"                 # Generic Child -> Parent (e.g. Clause -> Article)
    
    # --- Prerequisites & Requirements ---
    DIEU_KIEN_TIEN_QUYET = "DIEU_KIEN_TIEN_QUYET" # MON_HOC -> MON_HOC (Prerequisite)
    YEU_CAU_DIEU_KIEN = "YEU_CAU_DIEU_KIEN"       # MON_HOC -> DIEU_KIEN
    QUY_DINH_DIEU_KIEN = "QUY_DINH_DIEU_KIEN"     # QUY_DINH -> DIEU_KIEN
    YEU_CAU = "YEU_CAU"                           # Generic Requirement (A requires B)
    
    # --- Applicability & Governance ---
    AP_DUNG_CHO = "AP_DUNG_CHO"           # QUY_DINH -> DOI_TUONG
    CHI_PHOI = "CHI_PHOI"                 # QUY_DINH -> TAI_CHINH/MON_HOC (Governs)
    
    # --- Semantic & Equivalences (New) ---
    LIEN_QUAN_NOI_DUNG = "LIEN_QUAN_NOI_DUNG"
    THAY_THE = "THAY_THE"
    BO_SUNG = "BO_SUNG"
    TUONG_DUONG = "TUONG_DUONG"           # Equivalent (e.g., Table mapping)
    DAT_DIEM = "DAT_DIEM"                 # CHUNG_CHI -> DIEM_SO (Achieves score)
    MIEN_GIAM = "MIEN_GIAM"               # Condition -> Course/Fee (Exempts)
    
    # --- Legal Modification Relationships ---
    AMENDS = "AMENDS"                     # New document amends older document
    REPLACES = "REPLACES"                 # New document replaces older document
    SUPPLEMENTS = "SUPPLEMENTS"           # New document supplements older document
    REPEALS = "REPEALS"                   # New document repeals older document
    
    # --- Scheduling ---
    HOC_TRONG = "HOC_TRONG"               # MON_HOC -> KY_HOC
    DAY = "DAY"                           # GIANG_VIEN -> MON_HOC
    
    # --- Generic Fallbacks ---
    LIEN_QUAN = "LIEN_QUAN"               # General relation (fallback)
    QUY_DINH_KHAC = "QUY_DINH_KHAC"       # Misc regulations


@dataclass
class GraphNode:
    """
    Domain model for a graph node.
    
    Attributes:
        id: Unique identifier (optional, generated by Neo4j)
        category: Node category from CatRAG schema
        properties: Node properties as dict
    """
    category: NodeCategory
    properties: Dict[str, Any]
    id: Optional[str] = None
    
    def __post_init__(self):
        """Validate node properties against category requirements"""
        self._validate_properties()
    
    def _validate_properties(self):
        """
        Validate that required properties are present.
        Note: Requirements are kept minimal to allow flexibility during LLM extraction.
        """
        required_props = self._get_required_properties()
        for prop in required_props:
            if prop not in self.properties:
                # In strict mode we raise error, but for LLM extraction pipelines 
                # it's often better to just log or allow missing non-critical fields.
                # Here we enforce it to ensure Graph consistency.
                if prop == "id": continue # ID might be auto-generated
                pass 
                # raise ValueError(f"Missing required property '{prop}' for category {self.category}")
    
    def _get_required_properties(self) -> List[str]:
        """Get required properties for this node category"""
        requirements = {
            # Basic Types
            NodeCategory.MON_HOC: ["name"], # 'code' might not always be extracted
            NodeCategory.QUY_DINH: ["title"], # 'status' and 'valid_from' are optional
            NodeCategory.DIEU_KIEN: ["description"],
            NodeCategory.KHOA: ["name"],
            NodeCategory.NGANH: ["name"],
            NodeCategory.CHUONG_TRINH_DAO_TAO: ["name"],
            NodeCategory.SINH_VIEN: ["cohort"],
            NodeCategory.KY_HOC: ["code"],
            
            # New Extended Types
            NodeCategory.CHUNG_CHI: ["text"], # e.g. "Chứng chỉ IELTS"
            NodeCategory.DIEM_SO: ["text"],   # e.g. "6.5"
            NodeCategory.DO_KHO: ["text"],    # e.g. "B1"
            NodeCategory.DOI_TUONG: ["text"], # e.g. "Hệ đại trà"
            NodeCategory.TAI_CHINH: ["text"], # e.g. "Học phí học lại"
            NodeCategory.DIEU_KIEN_SO: ["text"] # e.g. "70 sinh viên"
        }
        return requirements.get(self.category, [])


@dataclass
class GraphRelationship:
    """
    Domain model for a graph relationship.
    
    Attributes:
        source_id: ID of source node
        target_id: ID of target node
        rel_type: Relationship type from CatRAG schema
        properties: Relationship properties
    """
    source_id: str
    target_id: str
    rel_type: RelationshipType
    properties: Dict[str, Any] = field(default_factory=dict)


@dataclass
class GraphPath:
    """
    Domain model for a path in the graph.
    """
    nodes: List[GraphNode]
    relationships: List[GraphRelationship]
    length: int = field(init=False)
    
    def __post_init__(self):
        self.length = len(self.relationships)
    
    def get_node_ids(self) -> List[str]:
        """Get list of node IDs in the path"""
        return [node.id for node in self.nodes if node.id]
    
    def get_relationship_types(self) -> List[str]:
        """Get list of relationship types in the path"""
        return [rel.rel_type.value for rel in self.relationships]


@dataclass
class SubGraph:
    """
    Domain model for a subgraph.
    """
    nodes: List[GraphNode]
    relationships: List[GraphRelationship]
    center_node_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def get_node_count(self) -> int:
        return len(self.nodes)
    
    def get_relationship_count(self) -> int:
        return len(self.relationships)
    
    def get_categories(self) -> List[str]:
        return list(set(node.category.value for node in self.nodes))


@dataclass
class GraphQuery:
    """
    Domain model for graph queries.
    """
    query_type: str  # e.g., "traverse", "shortest_path", "subgraph"
    start_node_id: Optional[str] = None
    end_node_id: Optional[str] = None
    relationship_types: List[RelationshipType] = field(default_factory=list)
    max_depth: int = 2
    filters: Dict[str, Any] = field(default_factory=dict)
    limit: int = 10


@dataclass
class QueryIntent(str, Enum):
    """
    CatRAG Query Intent Categories for Router Agent.
    """
    TIEN_QUYET = "tien_quyet"
    MO_TA_MON_HOC = "mo_ta_mon_hoc"
    DIEU_KIEN_TOT_NGHIEP = "dieu_kien_tot_nghiep"
    CHUONG_TRINH_DAO_TAO = "chuong_trinh_dao_tao"
    QUY_DINH_HOC_VU = "quy_dinh_hoc_vu"
    HOC_PHI = "hoc_phi"
    GENERAL = "general"


@dataclass
class RoutingDecision:
    """
    Routing decision made by Router Agent.
    """
    intent: QueryIntent
    confidence: float
    route_to: str  # "graph_traversal", "vector_search", "hybrid_search", "multi_hop_graph"
    extracted_entities: List[Dict[str, Any]] = field(default_factory=list)
    reasoning: Optional[str] = None
    
    def should_use_graph(self) -> bool:
        return self.route_to in ["graph_traversal", "multi_hop_graph", "hybrid_search"]
    
    def should_use_vector(self) -> bool:
        return self.route_to in ["vector_search", "hybrid_search"]


@dataclass
class Entity:
    """
    Extracted entity from text (aligned with CatRAG categories).
    """
    text: str
    type: str  # Should match NodeCategory values
    start: int
    end: int
    confidence: float = 1.0
    normalized: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "text": self.text,
            "type": self.type,
            "start": self.start,
            "end": self.end,
            "confidence": self.confidence,
            "normalized": self.normalized,
            "metadata": self.metadata
        }


@dataclass
class Relation:
    """
    Extracted relation from text.
    """
    source: Entity
    target: Entity
    rel_type: str  # Should match RelationshipType values
    confidence: float = 1.0
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "source": self.source.to_dict(),
            "target": self.target.to_dict(),
            "rel_type": self.rel_type,
            "confidence": self.confidence,
            "metadata": self.metadata
        }


# Helper functions for creating common node types

def create_mon_hoc_node(code: str, name: str, credits: int, **kwargs) -> GraphNode:
    """Create a MonHoc (course) node"""
    properties = {
        "code": code,
        "name": name,
        "credits": credits,
        **kwargs
    }
    return GraphNode(category=NodeCategory.MON_HOC, properties=properties)


def create_quy_dinh_node(qd_id: str, title: str, year: int, **kwargs) -> GraphNode:
    """Create a QuyDinh (regulation) node"""
    properties = {
        "id": qd_id,
        "title": title,
        "year": year,
        **kwargs
    }
    return GraphNode(category=NodeCategory.QUY_DINH, properties=properties)


def create_prerequisite_relationship(
    source_course_id: str,
    target_course_id: str,
    required: bool = True
) -> GraphRelationship:
    """Create a prerequisite relationship between courses"""
    return GraphRelationship(
        source_id=target_course_id,  # Note: reversed for prerequisite
        target_id=source_course_id,
        rel_type=RelationshipType.DIEU_KIEN_TIEN_QUYET,
        properties={
            "type": "bat_buoc" if required else "khuyen_nghi",
            "can_study_parallel": False
        }
    )